<!DOCTYPE html>
<html>
	<head>
		<title>VM Docs</title>
		<link rel="stylesheet" type="text/css" href="docs.css" />
		<script src="toc.js"></script>
	</head>
	<body>
		<div id="toc"></div>
		<main>
			<h1 class="toc-exclude">Virtual Machine</h1>
			<p>
				To achieve the goal of only executing esoteric languages, BF/M runs all executables
				in an esoteric virtual machine.
			</p>

			<h2>Registers</h2>
			<p>
				The virtual machine has 4 registers: <code>pc</code>, <code>cp</code>,
				<code>r</code>, and <code>flags</code>.
			</p>
			<p>
				<code>pc</code> is the program counter. It refers to the offset in the executable file
				which is being executed. This register can only be modified indirectly through the branch
				instruction.
			</p>
			<p>
				<code>cp</code> is the cell pointer. It contains the address of the current
				cell in memory.
			</p>
			<p>
				<code>r</code> is the general purpose register. It is 1 byte in size.
			</p>

			<h3>Flags Register</h3>
			<p>
				The <code>flags</code> register is a 4-bit register which contains the following bit flags:
			</p>
			<table>
				<tr>
					<th>Bit</th>
					<th>Flag</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><code>0</code></td>
					<td>Z</td>
					<td>Zero flag</td>
				</tr>
				<tr>
					<td><code>1</code></td>
					<td>N</td>
					<td>Negative flag</td>
				</tr>
				<tr>
					<td><code>2</code></td>
					<td>C</td>
					<td>Carry flag</td>
				</tr>
				<tr>
					<td><code>3</code></td>
					<td>V</td>
					<td>Overflow flag</td>
				</tr>
			</table>


			<h2>Memory</h2>
			<p>
				Memory is organized into a finite series of 1 byte cells. The lowest address is 0.
				<code>cp</code> is initialized to 0 when a program starts.
			</p>

			<h2>Instructions</h2>

			<table>
				<tr>
					<th>Opcode</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><code>0h</code></td>
					<td>nop</td>
				</tr>
				<tr>
					<td><code>1h</code></td>
					<td>Manipulate flags</td>
				</tr>
				<tr>
					<td><code>2h</code></td>
					<td>Branch</td>
				</tr>
				<tr>
					<td><code>3h</code></td>
					<td>Add immediate to cp</td>
				</tr>
				<tr>
					<td><code>4h</code></td>
					<td>Add immediate to cell</td>
				</tr>
				<tr>
					<td><code>5h</code></td>
					<td>Add register to cell</td>
				</tr>
				<tr>
					<td><code>6h</code></td>
					<td>Bitwise</td>
				</tr>
				<tr>
					<td><code>7h</code></td>
					<td>Load cell to register</td>
				</tr>
				<tr>
					<td><code>8h</code></td>
					<td>Load immediate to register</td>
				</tr>
				<tr>
					<td><code>9h</code></td>
					<td>Store register in cell</td>
				</tr>
				<tr>
					<td><code>Ah</code></td>
					<td>MMIO Read</td>
				</tr>
				<tr>
					<td><code>Bh</code></td>
					<td>MMIO Write</td>
				</tr>
			</table>

			<h3><code>nop</code></h3>
			<p>
				Does nothing. <code>nop</code> is always 1 nybble long, and always takes
				1 cycle to execute.
			</p>

			<h3>Manipulate Flags</h3>
			<p>
				The manipulate flags instruction sets or clears flags. It takes a nybble argument.
				The low two bits are the flag bit to target. The 2nd bit is whether to set (1) or
				clear (0) the flag. The high bit is reserved
			</p>

			<table>
				<caption>Control nybble</caption>
				<tr>
					<th>Bit</th>
					<td>3</td>
					<td>2</td>
					<td>1</td>
					<td>0</td>
				</tr>
				<tr>
					<th>Meaning</th>
					<td>Reserved</td>
					<td>Set</td>
					<td colspan="2">Flag</td>
				</tr>
			</table>

			<h3>Branch</h3>
			<p>
				The branch instruction sets <code>pc</code> to the given address if the condition is true.
			</p>
			<p>
				After the opcode, the instruction expects a nybble condition code, followed by an address.
				The below table describes the nybble condition code. The low 3 bits' values are determined
				by the condition table. The high bit, called the negate bit, dictates whether the
				condition should be negated after being evaluated.
			</p>

			<table>
				<tr>
					<th>Bit</th>
					<td>3</td>
					<td>2</td>
					<td>1</td>
					<td>0</td>
				</tr>
				<tr>
					<th>Meaning</th>
					<td>Negate</td>
					<td colspan="3">Condition code</td>
				</tr>
			</table>

			<br>

			<table>
				<caption>Branch condition codes</caption>
				<tr>
					<th>Code</th>
					<th>Test</th>
					<th>Description</th>
				</tr>
				<tr>
					<td><code>000</code></td>
					<td>-</td>
					<td>Always branch</td>
				</tr>
				<tr>
					<td><code>001</code></td>
					<td>Z</td>
					<td>Branch if zero flag is set</td>
				</tr>
				<tr>
					<td><code>010</code></td>
					<td>C</td>
					<td>Branch if carry flag is set</td>
				</tr>
				<tr>
					<td><code>011</code></td>
					<td>N</td>
					<td>Branch if negative flag is set</td>
				</tr>
				<tr>
					<td><code>100</code></td>
					<td>V</td>
					<td>Branch if overflow flag is set</td>
				</tr>
				<tr>
					<td><code>101</code></td>
					<td>N == V</td>
					<td>Branch if negative flag equals overflow flag</td>
				</tr>
				<tr>
					<td><code>110</code></td>
					<td>-</td>
					<td>Reserved</td>
				</tr>
				<tr>
					<td><code>111</code></td>
					<td>-</td>
					<td>Reserved</td>
				</tr>
			</table>

			<h3>Add immediate to <code>cp</code></h3>
			<p>
				This instruction adds an immediate signed byte to <code>cp</code>.
			</p>

			<h3>Add immediate to cell</h3>
			<p>
				This instruction adds an immediate signed byte to the cell pointed to by
				<code>cp</code>.
			</p>

			<h3>Add register to cell</h3>
			<p>
				This instruction adds the value in register <code>r</code> to the cell
				pointed to by <code>cp</code>.
			</p>

			<h3>Bitwise</h3>
			<p>
				There are four bitwise operations provided: nand, arithmetic left shift, arithmetic
				right shift, and logical right shift. These are all performed by the same opcode.
				The instruction takes a control nybble (see below table).
			</p>

			<table>
				<caption>Bitwise Instruction Control Nybble</caption>
				<tr>
					<th>Bit</th>
					<td>3</td>
					<td>2</td>
					<td>1</td>
					<td>0</td>
				</tr>
				<tr>
					<th>Meaning</th>
					<td>Source</td>
					<td>Target</td>
					<td colspan="2">Operation</td>
				</tr>
			</table>

			<p>
				The source bit selects whether the right hand operand is an immediate byte
				(<code>0</code>) or <code>r</code> (<code>1</code>).
			</p>
			<p>
				The target bit selects whether the left hand operand and destination of the operation
				is the current cell (<code>0</code>) or <code>r</code> (<code>1</code>).
			</p>
			<p>
				The operation bits select which bitwise operation to perform, according to the
				bitwise operation codes table.
			</p>

			<table>
				<caption>Bitwise operation codes</caption>
				<tr>
					<th>Code</th>
					<th>Operation</th>
				</tr>
				<tr>
					<td><code>00</code></td>
					<td>NAND</td>
				</tr>
				<tr>
					<td><code>01</code></td>
					<td>Left shift</td>
				</tr>
				<tr>
					<td><code>10</code></td>
					<td>Arithmetic right shift</td>
				</tr>
				<tr>
					<td><code>11</code></td>
					<td>Logical right shift</td>
				</tr>
			</table>

			<h3>Load cell to register</h3>
			<p>
				Copies the value in the current cell into <code>r</code>.
			</p>

			<h3>Load immediate to register</h3>
			<p>
				Loads an immediate byte into <code>r</code>.
			</p>

			<h3>Store register in cell</h3>
			<p>
				Writes the value in <code>r</code> to the current cell.
			</p>

			<!-- TODO: prevent reading & writing normal memory (consider using 27-bit offsets from 0x7c0000000 instead of addresses) -->
			<h3>MMIO Read</h3>
			<p>
				Reads the byte at the given address into <code>r</code>
			</p>

			<h3>MMIO Write</h3>
			<p>
				Writes <code>r</code> to the given address
			</p>
		</main>
	</body>
</html>